{"ast":null,"code":"import _isDate from \"lodash/isDate\";\nimport _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\n\n\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n\n  var rules = function (dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n\n  return rules(domain);\n}\n\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function (padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\n\nfunction getFlatData(dataset, axis) {\n  return _flatten(dataset).map(function (datum) {\n    return datum[\"_\".concat(axis)] && datum[\"_\".concat(axis)][1] !== undefined ? datum[\"_\".concat(axis)][1] : datum[\"_\".concat(axis)];\n  });\n}\n\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n\n  var getExtreme = function (arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n\n  return containsDate ? new Date(result) : result;\n} //eslint-disable-next-line max-statements\n\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]);\n  var paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  var paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  var simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  var paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  var addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n\n  var adjust = function (val, type) {\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    var initialPadding = {\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    }; // Adjust the domain by the initial padding\n\n    var adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    }; // re-calculate padding, taking the adjusted domain into account\n\n    var finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    }; // Adjust the domain by the final padding\n\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  } // default to minDomain / maxDomain if they exist\n\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\n\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\nexport function getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n      _props$startAngle = props.startAngle,\n      startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n      _props$endAngle = props.endAngle,\n      endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n\n  if (!categories) {\n    return undefined;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\nexport function getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n      _props$startAngle2 = props.startAngle,\n      startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n      _props$endAngle2 = props.endAngle,\n      endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\nexport function getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function (val) {\n    // d3-scale does not properly resolve very small differences.\n    var verySmallNumber = // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : +val - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : +val + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n\n  return +min === +max ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\nexport function getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n\n  if (propsDomain) {\n    return propsDomain;\n  }\n\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n\n  var ensureZero = function (domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n\n  var getDomainFunction = function () {\n    return getDomainFromData(props, axis, dataset);\n  };\n\n  var formatDomainFunction = function (domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\n\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\n\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\nexport function getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDomainComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}","map":{"version":3,"sources":["/Users/paulhinh/dev/tamuhack/EduCoin/node_modules/victory-core/es/victory-util/domain.js"],"names":["_isDate","_includes","_isFunction","_sortedUniq","_isPlainObject","_flatten","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","React","Data","Scale","Helpers","Collection","cleanDomain","domain","props","axis","scaleType","getScaleType","rules","dom","almostZero","Number","MAX_SAFE_INTEGER","domainOne","domainTwo","getDomainPadding","formatPadding","padding","left","right","domainPadding","getFlatData","dataset","map","datum","concat","undefined","getExtremeFromData","type","arguments","getExtreme","Math","max","apply","min","initialValue","Infinity","containsDate","result","reduce","memo","current0","current1","current","Date","padDomain","minDomain","getMinFromProps","maxDomain","getMaxFromProps","getMinValue","getMaxValue","currentAxis","getCurrentAxis","horizontal","range","getRange","rangeExtent","abs","paddedRangeExtent","paddedDomainExtent","valueOf","simplePadding","paddedDomain","singleQuadrantDomainPadding","addsQuadrants","adjust","val","coerce","initialPadding","adjustedDomain","finalPadding","finalDomain","getDomainFromMinMax","createDomainFunction","getDomainFromDataFunction","formatDomainFunction","getDomainFromData","formatDomain","propsDomain","getDomainFromProps","categories","getCategories","getDomainFromCategories","getDomain","polar","_props$startAngle","startAngle","_props$endAngle","endAngle","stringArray","containsStrings","getStringsFromCategories","stringMap","string","index","categoryValues","value","categoryDomain","getSymmetricDomain","getData","_props$startAngle2","_props$endAngle2","getSinglePointDomain","verySmallNumber","pow","verySmallDate","minVal","maxVal","getDomainWithZero","y0Min","_y0","ensureZero","defaultMin","maxDomainProp","minDomainProp","getDomainFunction","values","processedData","sort","a","b","step","isDomainComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,eAApB;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,OAAOC,WAAP,MAAwB,mBAAxB;AACA,OAAOC,WAAP,MAAwB,mBAAxB;AACA,OAAOC,cAAP,MAA2B,sBAA3B;AACA,OAAOC,QAAP,MAAqB,gBAArB;;AAEA,SAASC,kBAAT,CAA4BC,GAA5B,EAAiC;AAAE,SAAOC,kBAAkB,CAACD,GAAD,CAAlB,IAA2BE,gBAAgB,CAACF,GAAD,CAA3C,IAAoDG,kBAAkB,EAA7E;AAAkF;;AAErH,SAASA,kBAAT,GAA8B;AAAE,QAAM,IAAIC,SAAJ,CAAc,iDAAd,CAAN;AAAyE;;AAEzG,SAASF,gBAAT,CAA0BG,IAA1B,EAAgC;AAAE,MAAIC,MAAM,CAACC,QAAP,IAAmBC,MAAM,CAACH,IAAD,CAAzB,IAAmCG,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BN,IAA/B,MAAyC,oBAAhF,EAAsG,OAAOO,KAAK,CAACC,IAAN,CAAWR,IAAX,CAAP;AAA0B;;AAElK,SAASJ,kBAAT,CAA4BD,GAA5B,EAAiC;AAAE,MAAIY,KAAK,CAACE,OAAN,CAAcd,GAAd,CAAJ,EAAwB;AAAE,SAAK,IAAIe,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG,IAAIJ,KAAJ,CAAUZ,GAAG,CAACiB,MAAd,CAAvB,EAA8CF,CAAC,GAAGf,GAAG,CAACiB,MAAtD,EAA8DF,CAAC,EAA/D,EAAmE;AAAEC,MAAAA,IAAI,CAACD,CAAD,CAAJ,GAAUf,GAAG,CAACe,CAAD,CAAb;AAAmB;;AAAC,WAAOC,IAAP;AAAc;AAAE;AAEtK;;AAEA;;;AACA,OAAOE,KAAP,MAAkB,OAAlB;AACA,OAAO,KAAKC,IAAZ,MAAsB,QAAtB;AACA,OAAO,KAAKC,KAAZ,MAAuB,SAAvB;AACA,OAAO,KAAKC,OAAZ,MAAyB,WAAzB;AACA,OAAO,KAAKC,UAAZ,MAA4B,cAA5B,C,CAA4C;;AAE5C,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,KAA7B,EAAoCC,IAApC,EAA0C;AACxC,MAAIC,SAAS,GAAGP,KAAK,CAACQ,YAAN,CAAmBH,KAAnB,EAA0BC,IAA1B,CAAhB;;AAEA,MAAIC,SAAS,KAAK,KAAlB,EAAyB;AACvB,WAAOH,MAAP;AACD;;AAED,MAAIK,KAAK,GAAG,UAAUC,GAAV,EAAe;AACzB,QAAIC,UAAU,GAAGD,GAAG,CAAC,CAAD,CAAH,GAAS,CAAT,IAAcA,GAAG,CAAC,CAAD,CAAH,GAAS,CAAvB,GAA2B,CAAC,CAAD,GAAKE,MAAM,CAACC,gBAAvC,GAA0D,IAAID,MAAM,CAACC,gBAAtF;AACA,QAAIC,SAAS,GAAGJ,GAAG,CAAC,CAAD,CAAH,KAAW,CAAX,GAAeC,UAAf,GAA4BD,GAAG,CAAC,CAAD,CAA/C;AACA,QAAIK,SAAS,GAAGL,GAAG,CAAC,CAAD,CAAH,KAAW,CAAX,GAAeC,UAAf,GAA4BD,GAAG,CAAC,CAAD,CAA/C;AACA,WAAO,CAACI,SAAD,EAAYC,SAAZ,CAAP;AACD,GALD;;AAOA,SAAON,KAAK,CAACL,MAAD,CAAZ;AACD;;AAED,SAASY,gBAAT,CAA0BX,KAA1B,EAAiCC,IAAjC,EAAuC;AACrC,MAAIW,aAAa,GAAG,UAAUC,OAAV,EAAmB;AACrC,WAAO1B,KAAK,CAACE,OAAN,CAAcwB,OAAd,IAAyB;AAC9BC,MAAAA,IAAI,EAAED,OAAO,CAAC,CAAD,CADiB;AAE9BE,MAAAA,KAAK,EAAEF,OAAO,CAAC,CAAD;AAFgB,KAAzB,GAGH;AACFC,MAAAA,IAAI,EAAED,OADJ;AAEFE,MAAAA,KAAK,EAAEF;AAFL,KAHJ;AAOD,GARD;;AAUA,SAAOzC,cAAc,CAAC4B,KAAK,CAACgB,aAAP,CAAd,GAAsCJ,aAAa,CAACZ,KAAK,CAACgB,aAAN,CAAoBf,IAApB,CAAD,CAAnD,GAAiFW,aAAa,CAACZ,KAAK,CAACgB,aAAP,CAArG;AACD;;AAED,SAASC,WAAT,CAAqBC,OAArB,EAA8BjB,IAA9B,EAAoC;AAClC,SAAO5B,QAAQ,CAAC6C,OAAD,CAAR,CAAkBC,GAAlB,CAAsB,UAAUC,KAAV,EAAiB;AAC5C,WAAOA,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,CAAD,CAAL,IAA2BmB,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,CAAD,CAAL,CAAwB,CAAxB,MAA+BqB,SAA1D,GAAsEF,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,CAAD,CAAL,CAAwB,CAAxB,CAAtE,GAAmGmB,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,CAAD,CAA/G;AACD,GAFM,CAAP;AAGD;;AAED,SAASsB,kBAAT,CAA4BL,OAA5B,EAAqCjB,IAArC,EAA2C;AACzC,MAAIuB,IAAI,GAAGC,SAAS,CAACjC,MAAV,GAAmB,CAAnB,IAAwBiC,SAAS,CAAC,CAAD,CAAT,KAAiBH,SAAzC,GAAqDG,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAA/E;;AAEA,MAAIC,UAAU,GAAG,UAAUnD,GAAV,EAAe;AAC9B,WAAOiD,IAAI,KAAK,KAAT,GAAiBG,IAAI,CAACC,GAAL,CAASC,KAAT,CAAeF,IAAf,EAAqBrD,kBAAkB,CAACC,GAAD,CAAvC,CAAjB,GAAiEoD,IAAI,CAACG,GAAL,CAASD,KAAT,CAAeF,IAAf,EAAqBrD,kBAAkB,CAACC,GAAD,CAAvC,CAAxE;AACD,GAFD;;AAIA,MAAIwD,YAAY,GAAGP,IAAI,KAAK,KAAT,GAAiB,CAACQ,QAAlB,GAA6BA,QAAhD;AACA,MAAIC,YAAY,GAAG,KAAnB;;AAEA,MAAIC,MAAM,GAAG7D,QAAQ,CAAC6C,OAAD,CAAR,CAAkBiB,MAAlB,CAAyB,UAAUC,IAAV,EAAgBhB,KAAhB,EAAuB;AAC3D,QAAIiB,QAAQ,GAAGjB,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,EAAiB,GAAjB,CAAD,CAAL,KAAiCqB,SAAjC,GAA6CF,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,EAAiB,GAAjB,CAAD,CAAlD,GAA4EmB,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,CAAD,CAAhG;AACA,QAAIqC,QAAQ,GAAGlB,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,EAAiB,GAAjB,CAAD,CAAL,KAAiCqB,SAAjC,GAA6CF,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,EAAiB,GAAjB,CAAD,CAAlD,GAA4EmB,KAAK,CAAC,IAAIC,MAAJ,CAAWpB,IAAX,CAAD,CAAhG;AACA,QAAIsC,OAAO,GAAGb,UAAU,CAAC,CAACW,QAAD,EAAWC,QAAX,CAAD,CAAxB;AACAL,IAAAA,YAAY,GAAGA,YAAY,IAAII,QAAQ,YAAYG,IAApC,IAA4CF,QAAQ,YAAYE,IAA/E;AACA,WAAOd,UAAU,CAAC,CAACU,IAAD,EAAOG,OAAP,CAAD,CAAjB;AACD,GANY,EAMVR,YANU,CAAb;;AAQA,SAAOE,YAAY,GAAG,IAAIO,IAAJ,CAASN,MAAT,CAAH,GAAsBA,MAAzC;AACD,C,CAAC;;;AAGF,SAASO,SAAT,CAAmB1C,MAAnB,EAA2BC,KAA3B,EAAkCC,IAAlC,EAAwC;AACtC,MAAI,CAACD,KAAK,CAACgB,aAAX,EAA0B;AACxB,WAAOjB,MAAP;AACD;;AAED,MAAI2C,SAAS,GAAGC,eAAe,CAAC3C,KAAD,EAAQC,IAAR,CAA/B;AACA,MAAI2C,SAAS,GAAGC,eAAe,CAAC7C,KAAD,EAAQC,IAAR,CAA/B;AACA,MAAIY,OAAO,GAAGF,gBAAgB,CAACX,KAAD,EAAQC,IAAR,CAA9B;;AAEA,MAAI,CAACY,OAAO,CAACC,IAAT,IAAiB,CAACD,OAAO,CAACE,KAA9B,EAAqC;AACnC,WAAOhB,MAAP;AACD;;AAED,MAAI+B,GAAG,GAAGjC,UAAU,CAACiD,WAAX,CAAuB/C,MAAvB,CAAV;AACA,MAAI6B,GAAG,GAAG/B,UAAU,CAACkD,WAAX,CAAuBhD,MAAvB,CAAV;AACA,MAAIiD,WAAW,GAAGpD,OAAO,CAACqD,cAAR,CAAuBhD,IAAvB,EAA6BD,KAAK,CAACkD,UAAnC,CAAlB;AACA,MAAIC,KAAK,GAAGvD,OAAO,CAACwD,QAAR,CAAiBpD,KAAjB,EAAwBgD,WAAxB,CAAZ;AACA,MAAIK,WAAW,GAAG1B,IAAI,CAAC2B,GAAL,CAASH,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAzB,CAAlB;AACA,MAAII,iBAAiB,GAAG5B,IAAI,CAACC,GAAL,CAASyB,WAAW,GAAGxC,OAAO,CAACC,IAAtB,GAA6BD,OAAO,CAACE,KAA9C,EAAqD,CAArD,CAAxB;AACA,MAAIyC,kBAAkB,GAAG7B,IAAI,CAAC2B,GAAL,CAAS1B,GAAG,CAAC6B,OAAJ,KAAgB3B,GAAG,CAAC2B,OAAJ,EAAzB,IAA0CF,iBAA1C,GAA8DF,WAAvF;AACA,MAAIK,aAAa,GAAG;AAClB5C,IAAAA,IAAI,EAAE0C,kBAAkB,GAAG3C,OAAO,CAACC,IAA7B,GAAoCuC,WADxB;AAElBtC,IAAAA,KAAK,EAAEyC,kBAAkB,GAAG3C,OAAO,CAACE,KAA7B,GAAqCsC;AAF1B,GAApB;AAIA,MAAIM,YAAY,GAAG;AACjB7B,IAAAA,GAAG,EAAEA,GAAG,CAAC2B,OAAJ,KAAgBC,aAAa,CAAC5C,IADlB;AAEjBc,IAAAA,GAAG,EAAEA,GAAG,CAAC6B,OAAJ,KAAgBC,aAAa,CAAC3C;AAFlB,GAAnB;AAIA,MAAI6C,2BAA2B,GAAGxF,cAAc,CAAC4B,KAAK,CAAC4D,2BAAP,CAAd,GAAoD5D,KAAK,CAAC4D,2BAAN,CAAkC3D,IAAlC,CAApD,GAA8FD,KAAK,CAAC4D,2BAAtI;AACA,MAAIC,aAAa,GAAG/B,GAAG,IAAI,CAAP,IAAY6B,YAAY,CAAC7B,GAAb,IAAoB,CAAhC,IAAqCF,GAAG,IAAI,CAAP,IAAY+B,YAAY,CAAC/B,GAAb,IAAoB,CAAzF;;AAEA,MAAIkC,MAAM,GAAG,UAAUC,GAAV,EAAevC,IAAf,EAAqB;AAChC,QAAIwC,MAAM,GAAGxC,IAAI,KAAK,KAAT,IAAkBM,GAAG,IAAI,CAAzB,IAA8BiC,GAAG,IAAI,CAArC,IAA0CvC,IAAI,KAAK,KAAT,IAAkBI,GAAG,IAAI,CAAzB,IAA8BmC,GAAG,IAAI,CAA5F;AACA,WAAOC,MAAM,GAAG,CAAH,GAAOD,GAApB;AACD,GAHD;;AAKA,MAAIF,aAAa,IAAID,2BAA2B,KAAK,KAArD,EAA4D;AAC1D;AACA,QAAIK,cAAc,GAAG;AACnBnD,MAAAA,IAAI,EAAEa,IAAI,CAAC2B,GAAL,CAAS1B,GAAG,GAAGE,GAAf,IAAsBjB,OAAO,CAACC,IAA9B,GAAqCuC,WADxB;AAEnBtC,MAAAA,KAAK,EAAEY,IAAI,CAAC2B,GAAL,CAAS1B,GAAG,GAAGE,GAAf,IAAsBjB,OAAO,CAACE,KAA9B,GAAsCsC;AAF1B,KAArB,CAF0D,CAKvD;;AAEH,QAAIa,cAAc,GAAG;AACnBpC,MAAAA,GAAG,EAAEgC,MAAM,CAAChC,GAAG,CAAC2B,OAAJ,KAAgBQ,cAAc,CAACnD,IAAhC,EAAsC,KAAtC,CADQ;AAEnBc,MAAAA,GAAG,EAAEkC,MAAM,CAAClC,GAAG,CAAC6B,OAAJ,KAAgBQ,cAAc,CAAClD,KAAhC,EAAuC,KAAvC;AAFQ,KAArB,CAP0D,CAUvD;;AAEH,QAAIoD,YAAY,GAAG;AACjBrD,MAAAA,IAAI,EAAEa,IAAI,CAAC2B,GAAL,CAASY,cAAc,CAACtC,GAAf,GAAqBsC,cAAc,CAACpC,GAA7C,IAAoDjB,OAAO,CAACC,IAA5D,GAAmEuC,WADxD;AAEjBtC,MAAAA,KAAK,EAAEY,IAAI,CAAC2B,GAAL,CAASY,cAAc,CAACtC,GAAf,GAAqBsC,cAAc,CAACpC,GAA7C,IAAoDjB,OAAO,CAACE,KAA5D,GAAoEsC;AAF1D,KAAnB,CAZ0D,CAevD;;AAEHM,IAAAA,YAAY,GAAG;AACb7B,MAAAA,GAAG,EAAEgC,MAAM,CAAChC,GAAG,CAAC2B,OAAJ,KAAgBU,YAAY,CAACrD,IAA9B,EAAoC,KAApC,CADE;AAEbc,MAAAA,GAAG,EAAEkC,MAAM,CAAClC,GAAG,CAAC6B,OAAJ,KAAgBU,YAAY,CAACpD,KAA9B,EAAqC,KAArC;AAFE,KAAf;AAID,GAzDqC,CAyDpC;;;AAGF,MAAIqD,WAAW,GAAG;AAChBtC,IAAAA,GAAG,EAAEY,SAAS,KAAKpB,SAAd,GAA0BoB,SAA1B,GAAsCiB,YAAY,CAAC7B,GADxC;AAEhBF,IAAAA,GAAG,EAAEgB,SAAS,KAAKtB,SAAd,GAA0BsB,SAA1B,GAAsCe,YAAY,CAAC/B;AAFxC,GAAlB;AAIA,SAAOE,GAAG,YAAYU,IAAf,IAAuBZ,GAAG,YAAYY,IAAtC,GAA6C6B,mBAAmB,CAAC,IAAI7B,IAAJ,CAAS4B,WAAW,CAACtC,GAArB,CAAD,EAA4B,IAAIU,IAAJ,CAAS4B,WAAW,CAACxC,GAArB,CAA5B,CAAhE,GAAyHyC,mBAAmB,CAACD,WAAW,CAACtC,GAAb,EAAkBsC,WAAW,CAACxC,GAA9B,CAAnJ;AACD,C,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,SAAS0C,oBAAT,CAA8BC,yBAA9B,EAAyDC,oBAAzD,EAA+E;AACpFD,EAAAA,yBAAyB,GAAGrG,WAAW,CAACqG,yBAAD,CAAX,GAAyCA,yBAAzC,GAAqEE,iBAAjG;AACAD,EAAAA,oBAAoB,GAAGtG,WAAW,CAACsG,oBAAD,CAAX,GAAoCA,oBAApC,GAA2DE,YAAlF;AACA,SAAO,UAAU1E,KAAV,EAAiBC,IAAjB,EAAuB;AAC5B,QAAI0E,WAAW,GAAGC,kBAAkB,CAAC5E,KAAD,EAAQC,IAAR,CAApC;;AAEA,QAAI0E,WAAJ,EAAiB;AACf,aAAOH,oBAAoB,CAACG,WAAD,EAAc3E,KAAd,EAAqBC,IAArB,CAA3B;AACD;;AAED,QAAI4E,UAAU,GAAGnF,IAAI,CAACoF,aAAL,CAAmB9E,KAAnB,EAA0BC,IAA1B,CAAjB;AACA,QAAIF,MAAM,GAAG8E,UAAU,GAAGE,uBAAuB,CAAC/E,KAAD,EAAQC,IAAR,EAAc4E,UAAd,CAA1B,GAAsDN,yBAAyB,CAACvE,KAAD,EAAQC,IAAR,CAAtG;AACA,WAAOF,MAAM,GAAGyE,oBAAoB,CAACzE,MAAD,EAASC,KAAT,EAAgBC,IAAhB,CAAvB,GAA+CqB,SAA5D;AACD,GAVD;AAWD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASoD,YAAT,CAAsB3E,MAAtB,EAA8BC,KAA9B,EAAqCC,IAArC,EAA2C;AAChD,SAAOH,WAAW,CAAC2C,SAAS,CAAC1C,MAAD,EAASC,KAAT,EAAgBC,IAAhB,CAAV,EAAiCD,KAAjC,EAAwCC,IAAxC,CAAlB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS+E,SAAT,CAAmBhF,KAAnB,EAA0BC,IAA1B,EAAgC;AACrC,SAAOqE,oBAAoB,GAAGtE,KAAH,EAAUC,IAAV,CAA3B;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS8E,uBAAT,CAAiC/E,KAAjC,EAAwCC,IAAxC,EAA8C4E,UAA9C,EAA0D;AAC/DA,EAAAA,UAAU,GAAGA,UAAU,IAAInF,IAAI,CAACoF,aAAL,CAAmB9E,KAAnB,EAA0BC,IAA1B,CAA3B;AACA,MAAIgF,KAAK,GAAGjF,KAAK,CAACiF,KAAlB;AAAA,MACIC,iBAAiB,GAAGlF,KAAK,CAACmF,UAD9B;AAAA,MAEIA,UAAU,GAAGD,iBAAiB,KAAK,KAAK,CAA3B,GAA+B,CAA/B,GAAmCA,iBAFpD;AAAA,MAGIE,eAAe,GAAGpF,KAAK,CAACqF,QAH5B;AAAA,MAIIA,QAAQ,GAAGD,eAAe,KAAK,KAAK,CAAzB,GAA6B,GAA7B,GAAmCA,eAJlD;;AAMA,MAAI,CAACP,UAAL,EAAiB;AACf,WAAOvD,SAAP;AACD;;AAED,MAAIoB,SAAS,GAAGC,eAAe,CAAC3C,KAAD,EAAQC,IAAR,CAA/B;AACA,MAAI2C,SAAS,GAAGC,eAAe,CAAC7C,KAAD,EAAQC,IAAR,CAA/B;AACA,MAAIqF,WAAW,GAAGzF,UAAU,CAAC0F,eAAX,CAA2BV,UAA3B,IAAyCnF,IAAI,CAAC8F,wBAAL,CAA8BxF,KAA9B,EAAqCC,IAArC,CAAzC,GAAsF,EAAxG;AACA,MAAIwF,SAAS,GAAGH,WAAW,CAAC9F,MAAZ,KAAuB,CAAvB,GAA2B,IAA3B,GAAkC8F,WAAW,CAACnD,MAAZ,CAAmB,UAAUC,IAAV,EAAgBsD,MAAhB,EAAwBC,KAAxB,EAA+B;AAClGvD,IAAAA,IAAI,CAACsD,MAAD,CAAJ,GAAeC,KAAK,GAAG,CAAvB;AACA,WAAOvD,IAAP;AACD,GAHiD,EAG/C,EAH+C,CAAlD;AAIA,MAAIwD,cAAc,GAAGH,SAAS,GAAGZ,UAAU,CAAC1D,GAAX,CAAe,UAAU0E,KAAV,EAAiB;AAC/D,WAAOJ,SAAS,CAACI,KAAD,CAAhB;AACD,GAFgC,CAAH,GAEzBhB,UAFL;AAGA,MAAI/C,GAAG,GAAGY,SAAS,KAAKpB,SAAd,GAA0BoB,SAA1B,GAAsC7C,UAAU,CAACiD,WAAX,CAAuB8C,cAAvB,CAAhD;AACA,MAAIhE,GAAG,GAAGgB,SAAS,KAAKtB,SAAd,GAA0BsB,SAA1B,GAAsC/C,UAAU,CAACkD,WAAX,CAAuB6C,cAAvB,CAAhD;AACA,MAAIE,cAAc,GAAGzB,mBAAmB,CAACvC,GAAD,EAAMF,GAAN,CAAxC;AACA,SAAOqD,KAAK,IAAIhF,IAAI,KAAK,GAAlB,IAAyB0B,IAAI,CAAC2B,GAAL,CAAS6B,UAAU,GAAGE,QAAtB,MAAoC,GAA7D,GAAmEU,kBAAkB,CAACD,cAAD,EAAiBF,cAAjB,CAArF,GAAwHE,cAA/H;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASrB,iBAAT,CAA2BzE,KAA3B,EAAkCC,IAAlC,EAAwCiB,OAAxC,EAAiD;AACtDA,EAAAA,OAAO,GAAGA,OAAO,IAAIxB,IAAI,CAACsG,OAAL,CAAahG,KAAb,CAArB;AACA,MAAIiF,KAAK,GAAGjF,KAAK,CAACiF,KAAlB;AAAA,MACIgB,kBAAkB,GAAGjG,KAAK,CAACmF,UAD/B;AAAA,MAEIA,UAAU,GAAGc,kBAAkB,KAAK,KAAK,CAA5B,GAAgC,CAAhC,GAAoCA,kBAFrD;AAAA,MAGIC,gBAAgB,GAAGlG,KAAK,CAACqF,QAH7B;AAAA,MAIIA,QAAQ,GAAGa,gBAAgB,KAAK,KAAK,CAA1B,GAA8B,GAA9B,GAAoCA,gBAJnD;AAKA,MAAIxD,SAAS,GAAGC,eAAe,CAAC3C,KAAD,EAAQC,IAAR,CAA/B;AACA,MAAI2C,SAAS,GAAGC,eAAe,CAAC7C,KAAD,EAAQC,IAAR,CAA/B;;AAEA,MAAIiB,OAAO,CAAC1B,MAAR,GAAiB,CAArB,EAAwB;AACtB,WAAOkD,SAAS,KAAKpB,SAAd,IAA2BsB,SAAS,KAAKtB,SAAzC,GAAqD+C,mBAAmB,CAAC3B,SAAD,EAAYE,SAAZ,CAAxE,GAAiGtB,SAAxG;AACD;;AAED,MAAIQ,GAAG,GAAGY,SAAS,KAAKpB,SAAd,GAA0BoB,SAA1B,GAAsCnB,kBAAkB,CAACL,OAAD,EAAUjB,IAAV,EAAgB,KAAhB,CAAlE;AACA,MAAI2B,GAAG,GAAGgB,SAAS,KAAKtB,SAAd,GAA0BsB,SAA1B,GAAsCrB,kBAAkB,CAACL,OAAD,EAAUjB,IAAV,EAAgB,KAAhB,CAAlE;AACA,MAAIF,MAAM,GAAGsE,mBAAmB,CAACvC,GAAD,EAAMF,GAAN,CAAhC;AACA,SAAOqD,KAAK,IAAIhF,IAAI,KAAK,GAAlB,IAAyB0B,IAAI,CAAC2B,GAAL,CAAS6B,UAAU,GAAGE,QAAtB,MAAoC,GAA7D,GAAmEU,kBAAkB,CAAChG,MAAD,EAASkB,WAAW,CAACC,OAAD,EAAUjB,IAAV,CAApB,CAArF,GAA4HF,MAAnI;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASsE,mBAAT,CAA6BvC,GAA7B,EAAkCF,GAAlC,EAAuC;AAC5C,MAAIuE,oBAAoB,GAAG,UAAUpC,GAAV,EAAe;AACxC;AACA,QAAIqC,eAAe,GAAG;AACtBrC,IAAAA,GAAG,KAAK,CAAR,GAAY,IAAIpC,IAAI,CAAC0E,GAAL,CAAS,EAAT,EAAa,CAAC,EAAd,CAAhB,GAAoC1E,IAAI,CAAC0E,GAAL,CAAS,EAAT,EAAa,CAAC,EAAd,CADpC;AAEA,QAAIC,aAAa,GAAG,CAApB;AACA,QAAIC,MAAM,GAAGxC,GAAG,YAAYvB,IAAf,GAAsB,IAAIA,IAAJ,CAAS,CAACuB,GAAD,GAAOuC,aAAhB,CAAtB,GAAuD,CAACvC,GAAD,GAAOqC,eAA3E;AACA,QAAII,MAAM,GAAGzC,GAAG,YAAYvB,IAAf,GAAsB,IAAIA,IAAJ,CAAS,CAACuB,GAAD,GAAOuC,aAAhB,CAAtB,GAAuD,CAACvC,GAAD,GAAOqC,eAA3E;AACA,WAAOrC,GAAG,KAAK,CAAR,GAAY,CAAC,CAAD,EAAIyC,MAAJ,CAAZ,GAA0B,CAACD,MAAD,EAASC,MAAT,CAAjC;AACD,GARD;;AAUA,SAAO,CAAC1E,GAAD,KAAS,CAACF,GAAV,GAAgBuE,oBAAoB,CAACvE,GAAD,CAApC,GAA4C,CAACE,GAAD,EAAMF,GAAN,CAAnD;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASgD,kBAAT,CAA4B5E,KAA5B,EAAmCC,IAAnC,EAAyC;AAC9C,MAAIyC,SAAS,GAAGC,eAAe,CAAC3C,KAAD,EAAQC,IAAR,CAA/B;AACA,MAAI2C,SAAS,GAAGC,eAAe,CAAC7C,KAAD,EAAQC,IAAR,CAA/B;;AAEA,MAAI7B,cAAc,CAAC4B,KAAK,CAACD,MAAP,CAAd,IAAgCC,KAAK,CAACD,MAAN,CAAaE,IAAb,CAApC,EAAwD;AACtD,WAAOD,KAAK,CAACD,MAAN,CAAaE,IAAb,CAAP;AACD,GAFD,MAEO,IAAId,KAAK,CAACE,OAAN,CAAcW,KAAK,CAACD,MAApB,CAAJ,EAAiC;AACtC,WAAOC,KAAK,CAACD,MAAb;AACD,GAFM,MAEA,IAAI2C,SAAS,KAAKpB,SAAd,IAA2BsB,SAAS,KAAKtB,SAA7C,EAAwD;AAC7D,WAAO+C,mBAAmB,CAAC3B,SAAD,EAAYE,SAAZ,CAA1B;AACD;;AAED,SAAOtB,SAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASmF,iBAAT,CAA2BzG,KAA3B,EAAkCC,IAAlC,EAAwC;AAC7C,MAAI0E,WAAW,GAAGC,kBAAkB,CAAC5E,KAAD,EAAQC,IAAR,CAApC;;AAEA,MAAI0E,WAAJ,EAAiB;AACf,WAAOA,WAAP;AACD;;AAED,MAAIzD,OAAO,GAAGxB,IAAI,CAACsG,OAAL,CAAahG,KAAb,CAAd;AACA,MAAI0G,KAAK,GAAGxF,OAAO,CAACiB,MAAR,CAAe,UAAUL,GAAV,EAAeV,KAAf,EAAsB;AAC/C,WAAOA,KAAK,CAACuF,GAAN,GAAY7E,GAAZ,GAAkBV,KAAK,CAACuF,GAAxB,GAA8B7E,GAArC;AACD,GAFW,EAETE,QAFS,CAAZ;;AAIA,MAAI4E,UAAU,GAAG,UAAU7G,MAAV,EAAkB;AACjC,QAAIE,IAAI,KAAK,GAAb,EAAkB;AAChB,aAAOF,MAAP;AACD;;AAED,QAAI8G,UAAU,GAAGH,KAAK,KAAK1E,QAAV,GAAqB0E,KAArB,GAA6B,CAA9C;AACA,QAAII,aAAa,GAAGjE,eAAe,CAAC7C,KAAD,EAAQC,IAAR,CAAnC;AACA,QAAI8G,aAAa,GAAGpE,eAAe,CAAC3C,KAAD,EAAQC,IAAR,CAAnC;AACA,QAAI2B,GAAG,GAAGkF,aAAa,KAAKxF,SAAlB,GAA8BwF,aAA9B,GAA8CjH,UAAU,CAACkD,WAAX,CAAuBhD,MAAvB,EAA+B8G,UAA/B,CAAxD;AACA,QAAI/E,GAAG,GAAGiF,aAAa,KAAKzF,SAAlB,GAA8ByF,aAA9B,GAA8ClH,UAAU,CAACiD,WAAX,CAAuB/C,MAAvB,EAA+B8G,UAA/B,CAAxD;AACA,WAAOxC,mBAAmB,CAACvC,GAAD,EAAMF,GAAN,CAA1B;AACD,GAXD;;AAaA,MAAIoF,iBAAiB,GAAG,YAAY;AAClC,WAAOvC,iBAAiB,CAACzE,KAAD,EAAQC,IAAR,EAAciB,OAAd,CAAxB;AACD,GAFD;;AAIA,MAAIsD,oBAAoB,GAAG,UAAUzE,MAAV,EAAkB;AAC3C,WAAO2E,YAAY,CAACkC,UAAU,CAAC7G,MAAD,CAAX,EAAqBC,KAArB,EAA4BC,IAA5B,CAAnB;AACD,GAFD;;AAIA,SAAOqE,oBAAoB,CAAC0C,iBAAD,EAAoBxC,oBAApB,CAApB,CAA8DxE,KAA9D,EAAqEC,IAArE,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS4C,eAAT,CAAyB7C,KAAzB,EAAgCC,IAAhC,EAAsC;AAC3C,MAAI7B,cAAc,CAAC4B,KAAK,CAAC4C,SAAP,CAAd,IAAmC5C,KAAK,CAAC4C,SAAN,CAAgB3C,IAAhB,MAA0BqB,SAAjE,EAA4E;AAC1E,WAAOtB,KAAK,CAAC4C,SAAN,CAAgB3C,IAAhB,CAAP;AACD;;AAED,SAAO,OAAOD,KAAK,CAAC4C,SAAb,KAA2B,QAA3B,IAAuC5E,OAAO,CAACgC,KAAK,CAAC4C,SAAP,CAA9C,GAAkE5C,KAAK,CAAC4C,SAAxE,GAAoFtB,SAA3F;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASqB,eAAT,CAAyB3C,KAAzB,EAAgCC,IAAhC,EAAsC;AAC3C,MAAI7B,cAAc,CAAC4B,KAAK,CAAC0C,SAAP,CAAd,IAAmC1C,KAAK,CAAC0C,SAAN,CAAgBzC,IAAhB,MAA0BqB,SAAjE,EAA4E;AAC1E,WAAOtB,KAAK,CAAC0C,SAAN,CAAgBzC,IAAhB,CAAP;AACD;;AAED,SAAO,OAAOD,KAAK,CAAC0C,SAAb,KAA2B,QAA3B,IAAuC1E,OAAO,CAACgC,KAAK,CAAC0C,SAAP,CAA9C,GAAkE1C,KAAK,CAAC0C,SAAxE,GAAoFpB,SAA3F;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASyE,kBAAT,CAA4BhG,MAA5B,EAAoCkH,MAApC,EAA4C;AACjD,MAAIC,aAAa,GAAG/I,WAAW,CAAC8I,MAAM,CAACE,IAAP,CAAY,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC1D,WAAOD,CAAC,GAAGC,CAAX;AACD,GAF+B,CAAD,CAA/B;;AAIA,MAAIC,IAAI,GAAGJ,aAAa,CAAC,CAAD,CAAb,GAAmBA,aAAa,CAAC,CAAD,CAA3C;AACA,SAAO,CAACnH,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAAD,CAAN,GAAYuH,IAAxB,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,iBAAT,CAA2BC,SAA3B,EAAsC;AAC3C,MAAIC,OAAO,GAAG,UAAUC,KAAV,EAAiB;AAC7B,WAAOA,KAAK,IAAIA,KAAK,CAAClG,IAAf,GAAsBkG,KAAK,CAAClG,IAAN,CAAWmG,IAAjC,GAAwC,EAA/C;AACD,GAFD;;AAIA,MAAIA,IAAI,GAAGF,OAAO,CAACD,SAAD,CAAlB;;AAEA,MAAIG,IAAI,KAAK,QAAb,EAAuB;AACrB,QAAIC,QAAQ,GAAGnI,KAAK,CAACoI,QAAN,CAAeC,OAAf,CAAuBN,SAAS,CAACxH,KAAV,CAAgB4H,QAAvC,CAAf;AACAD,IAAAA,IAAI,GAAGC,QAAQ,CAACpI,MAAT,GAAkBiI,OAAO,CAACG,QAAQ,CAAC,CAAD,CAAT,CAAzB,GAAyC,EAAhD;AACD;;AAED,MAAIG,SAAS,GAAG,CAAC,MAAD,EAAS,MAAT,EAAiB,KAAjB,EAAwB,SAAxB,EAAmC,aAAnC,EAAkD,UAAlD,EAA8D,OAA9D,EAAuE,WAAvE,EAAoF,MAApF,EAA4F,KAA5F,EAAmG,SAAnG,EAA8G,OAA9G,EAAuH,SAAvH,CAAhB;AACA,SAAO9J,SAAS,CAAC8J,SAAD,EAAYJ,IAAZ,CAAhB;AACD","sourcesContent":["import _isDate from \"lodash/isDate\";\nimport _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n\n  var rules = function (dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n\n  return rules(domain);\n}\n\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function (padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\n\nfunction getFlatData(dataset, axis) {\n  return _flatten(dataset).map(function (datum) {\n    return datum[\"_\".concat(axis)] && datum[\"_\".concat(axis)][1] !== undefined ? datum[\"_\".concat(axis)][1] : datum[\"_\".concat(axis)];\n  });\n}\n\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n\n  var getExtreme = function (arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n\n  return containsDate ? new Date(result) : result;\n} //eslint-disable-next-line max-statements\n\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]);\n  var paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  var paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  var simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  var paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  var addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n\n  var adjust = function (val, type) {\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    var initialPadding = {\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    }; // Adjust the domain by the initial padding\n\n    var adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    }; // re-calculate padding, taking the adjusted domain into account\n\n    var finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    }; // Adjust the domain by the final padding\n\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  } // default to minDomain / maxDomain if they exist\n\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\n\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\nexport function getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n      _props$startAngle = props.startAngle,\n      startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n      _props$endAngle = props.endAngle,\n      endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n\n  if (!categories) {\n    return undefined;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\nexport function getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n      _props$startAngle2 = props.startAngle,\n      startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n      _props$endAngle2 = props.endAngle,\n      endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\nexport function getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function (val) {\n    // d3-scale does not properly resolve very small differences.\n    var verySmallNumber = // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : +val - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : +val + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n\n  return +min === +max ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\nexport function getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\nexport function getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n\n  if (propsDomain) {\n    return propsDomain;\n  }\n\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n\n  var ensureZero = function (domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n\n  var getDomainFunction = function () {\n    return getDomainFromData(props, axis, dataset);\n  };\n\n  var formatDomainFunction = function (domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\n\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\n\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\nexport function getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDomainComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}"]},"metadata":{},"sourceType":"module"}